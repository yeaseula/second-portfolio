## description

> 프로젝트 소개

- Javascript class 문법을 처음 학습한 이후,객체지향 개념을 실제 적용해보기 위해 제작한 **턴제 판타지 미니 게임** 입니다.

- 유저는 용사팀과 괴수팀에서 각각 하나의 캐릭터를 선택하고 캐릭터 고유의 능력치를 기반으로 공격하며 전투를 진행할 수 있습니다.

- 각 캐릭터는 **공통 베이스 클래스**를 상속받아 설계했으며,공격력, 체력, 특성 등의 차이를 통해 전투 결과가 달라지도록 구현했습니다.

- 캐릭터 선택 화면에서는 웅장한 판타지 분위기를 주기 위해 AI를 활용하여 이미지를 제작했고,실제 전투 화면에서는 반전있는 귀여운 캐릭터를 사용해 재미를 전달하고자 했습니다.

## skillPoint

> 설계

- Javascript Class: class문법을 중심으로 상속을 통해 다양한 캐릭터를 구현. 공통 속성(HP, 공격 기능)을 베이스 클래스로 정의하고 extend를 이용해 각 캐릭터마다 고유 특성을 부여

> 에셋 제작

- AI 활용 이미지 제작: 판타지,중세 유럽 콘셉트에 맞는 캐릭터 에셋 확보를 위해 AI를 활용

## retrospect

이번 캐릭터 시스템을 만들면서 가장 크게 체감한 건

class 확장과 오버라이드의 위력이었다.

솔직히 이전까지는 “extends 쓰면 물려받는 거지” 정도의 느낌이었다.

그런데 직접 여러 캐릭터를 만들어보면서 생각이 완전히 달라졌다.

> 오버라이드는 단순한 덮어쓰기가 아니다!

Hero를 만들면서 처음으로 “기능 확장”이라는 걸 제대로 경험했다.

기본 공격 로직은 부모 클래스에 그대로 두고,

자식 클래스에서 확률적으로 2배 데미지를 추가했다.

이 과정에서 느낀 건

- 부모 코드를 건드리지 않고
- 자식에서 기능을 확장할 수 있다는 점이 정말 강력하다는 것

특히 super.attack()을 활용해
기존 로직을 재사용하면서 기능만 덧붙이는 방식은
OOP가 왜 존재하는지 이해하게 해줬다.

> 매개변수 설계의 중요성

구현 중에 가장 고민됐던 건 부모 attack 함수의 매개변수 구조였다.

단순히 (target, isPower) 식으로 넘기면 변수 순서가 바뀌는 순간 버그가 날 수 있다.

그래서 선택한 게 객체 리터럴 방식이었다.

이 방식을 선택하며

확장 가능성 고려가 중요하다는 점, 안전한 인터페이스 설계가 유지보수의 용이성을 좌우한다는 점 이었다.

이건 단순 구현을 넘어서 “설계”를 고민한 첫 순간이었다.

> 상태 관리의 불안함

마법사 기능을 구현하면서 count 변수를 도입했다.

기능은 잘 동작했지만 찝찝함이 남아있다.

“이렇게 상태 변수를 계속 추가하면 구조가 복잡해지지 않을까?”

이건 아마 내가 처음으로 확장성과 복잡도를 동시에 고민한 순간이었던 것 같다.

기능은 되지만, 구조는 점점 커진다.

이 감각을 느꼈다는 것 자체가 이번 구현에서 가장 큰 깨달음이었다.

> 책임의 위치를 고민하기 시작함

탱커를 만들면서 구조를 한 번 바꿨다.

처음엔 공격자가 “탱커인지 확인해서” 데미지를 줄일까 생각했다.

하지만 그건 부모 클래스가 자식을 구분하는 구조가 된다.
그건 확장의 의미가 사라지는 설계였다.

그래서 구조를 이렇게 바꿨다

- 공격자는 공격만 한다
- 피격자가 데미지를 처리한다
- 탱커는 receiveDamage를 오버라이드한다

기능을 바꾸는 건 조건문이 아니라, 오버라이드로 해결하는 게 더 객체지향적이라는 것을 느꼈다.

> 아쉬웠던 점

아직 효과나 상태를 객체로 분리하는 수준까지는 가지 못했다.
그리고 base가 되는 로직이 여전히 무겁다는 점, 그렇기때문에 타인이 봤을 땐 명확하고 간결하다는 느낌은
주지 못할 것 같다는 점이 아쉽다.
