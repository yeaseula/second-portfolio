## description

> 프로젝트 소개

- 사용자의 리뷰 데이터와 관심분야를 분석해 맞춤형 도서를 추천하고,
  독서 시간 기록 및 습관 형성을 지원하는 개인화 독서 관리 서비스

> 주요 기능

- 리뷰, 프로필 관심 분야 기반으로 맞춤형 도서 추천
- 스톱워치 기능으로 독서 시간 트래킹 및 로그 관리
- 리뷰 작성 시 캘린더 스탬프로 독서 습관 시각화
- 다크모드 / 폰트 크기 조절 등 사용자 맞춤 설정

> 리팩토링 목적

- HTML 기반 구조에서 CRUD 기능 확장 및 상태관리의 한계가 있었음
- 인증(회원가입/로그인) 기능 부재로 개인화 서비스 구현이 어려웠음
- 초기 데이터 패치 과정에서 네트워크 지연이 발생, 로딩 성능 개선 필요성을 인식
- 인터랙션 중심 서비스 특성상 페이지 단위가 아닌 컴포넌트 단위 설계의 필요성을 느껴 구조 개선을 결정

> 성능 개선 리포트

- 성능 개선 3대 핵심 요인

1. ❁ 서버 사이드 렌더링, 데이터 병렬 패칭 활용 : Next.js 서버 컴포넌트를 활용해 유저 데이터를 한 번에 병렬로 불러와 화면이 뜨기 까지 대기 시간을 감소
2. ❁ Next.js 내장 최적화 도구 활용 : font, 이미지 에셋에 Next.js 최적화 기능을 적용해 불필요한 네트워크 요청 방지
3. ❁ 가벼운 코드 지향

![무거운 라이브러리 코어](/image/bookdam/bookdam-img-5.png)
기존 코어가 무거운 애니메이션 라이브러리(Lottie)를 제거하고 CSS만 활용하는 방안 채택 → 낭비되는 리소스를 최소화 하도록 노력

- 개선 결과

1. ❁ 리소스 완료 시간 **(14.12초 → 4.62초 67% 단축)**

![리팩토링 전 리소스 완료 시간](/image/bookdam/bookdam-img-1.png)
![리팩토링 후 리소스 완료 시간](/image/bookdam/bookdam-img-2.png)
_(위) 버전 1 레거시 구조 / (아래) 버전 2 리팩토링_

2. ❁ 주요 JS 파일 전송 속도

![리팩토링 전 JS 파일 전송 속도](/image/bookdam/bookdam-img-3.png)
![리팩토링 후 JS 파일 전송 속도](/image/bookdam/bookdam-img-4.png)

## skills

> 개발 환경 (Frontend Framework)

- React : 컴포넌트 단위 렌더링으로 인터랙티브한 독서 기록 서비스에 적합.
- Next.js : 서버 사이드 렌더링(SSR)으로 초기 렌더링 속도 개선.
- TypeScript : 데이터 타입과 상태를 명확히 구분, CRUD 구현 시 안정성 확보.

> 백엔드

- Supabase :회원가입/로그인과 CRUD를 한 번에 처리 가능, SQL 기반 테이블로 데이터 관계 설계 용이.

> 상태관리

- Zustand: 간결한 API, TypeScript 지원, 커뮤니티 풍부, 전역 상태 관리와 유지보수에 적합.

> 선택한 라이브러리

- React Error Boundary: 개인화 서비스 구조에서 에러 처리 복잡도를 최소화.
- Swiper: 접근성과 커뮤니티가 검증되었으며 직접 접근성 구현 대비 유지보수 효율적.
- React-hook-form: 폼 유효성 검사와 관리가 간편하여 UX 향상.

> 선택하지 않은 라이브러리

- Lottie: 네비게이션 영역에서 과도한 리소스라고 판단해 제거 후 CSS 인터렉션으로 대체.

## trouble

> Form 필드의 UX / 성능 충돌

**문제**

- 초기 회원가입 폼의 유효성 검사 onBlur 처리로 UX 저하, 폼 신뢰성 하락 문제 발생

**개선 시도**

- onChange 방식으로 전환 후 리렌더 폭증
- 이후 state를 ref 도입, useCallback, memo 적용으로 리렌더는 줄었지만 상태와 유효성 로직의 복잡성 증가로 유지보수의 난이도 상승

**해결**

- 전환점 : "리렌더가 항상 나쁜 것은 아니다" 라는 점을 인식.
- 중요한 것은 무거운 컴포넌트, 무거운(복잡한)연산의 재실행이라는 점을 인식.
- 리렌더에 집중하기보다 최대한 간결하고,
  유지보수가 용이한 코드를 작성하려는 시도를 하던 중
  react-hook-form 도입

**결과**

- UX개선과 코드의 복잡도 감소
- input, textarea, select 등 폼에 필요한 필드의 분리로 협업 시에도 안전하고 빠른 개발 가능

> 썸네일 API 호출 구조 개선

**문제**

- 리뷰 리스트에서 분리한 썸네일 컴포넌트가 개별적으로 외부 API를 호출하며
  동일 렌더 사이클 내 다수의 네트워크 요청 발생.
- 이로 인해 간헐적 API 실패 문제가 발생함을 인지함.
- 다수의 API호출로 리뷰 데이터가 증가 할 경우 무수히 많은 API 요청이 발생 할 것을 예상함.

**원인 분석**

- 세부 컴포넌트 단위에서 데이터 패치를 수행해 요청 제어가 불가능함.
- 가장 작은 단위의 재사용되는 컴포넌트에서 api 요청하는 구조 설계가 잘못되었음.

**해결**

- 데이터 패치 책임을 최상위 컴포넌트로 승격 후 모든 리뷰 데이터의 썸네일을 병렬로 호출 처리.
- 기존 리뷰 데이터에 썸네일을 추가한 새로운 배열을 만든 후 하위 컴포넌트에 전달.
- 컴포넌트 언마운트 시 자동으로 호출 요청을 취소하도록 controller를 함께 전달.
- 썸네일 패치 실패는 치명적인 에러가 아니라고 판단해 요청에 실패해도 기본 썸네일이 노출되도록 하고,
  하나의 데이터 패치 실패가 전체 구조에 영향을 주지 않도록 재설계.

**결과**

- 간헐적 에러 제거 및 데이터 흐름을 명확히 함.
- 다수의 썸네일 데이터 호출을 병렬 처리해 하나의 실패가 전체의 실패로 이어지지 않도록 함.

> 에러 처리 구조 재설계

- Supabase 데이터 패치 실패와 “유저 데이터 없음” 상태를 구분하지 못하는 구조적 문제 발견
- 응답 타입을 data | error로 분리하여 에러 흐름 명확화
- 서버 → 페이지 → 컴포넌트 단위로 에러 바운더리 적용

> 모달 중첩 구조로 인한 접근성 문제

- 중첩 모달 구조에서 포커스 트랩이 정상 동작하지 않는 문제 발생
- 모든 모달을 분리하고, UI와 데이터 로직을 상위 컴포넌트로 이동
- 접근성 개선 및 모달 컴포넌트의 재사용이 가능하도록 구조 개선

## retrospect

> 단순 리팩토링이 아닌, 관점의 전환

책담 버전1은 포트폴리오 결과물을 만드는 데 목적이 있었다.

하지만 개발을 진행하면서 점점 의문이 생겼다.

**"React라면 이렇게 개발했을까? 이 구조가 정말 프론트엔드다운 설계일까?"**

처음에는 기능이 동작하는 것이 기준이었다.

하지만 정보처리기사 공부를 통해 데이터베이스 기초를 배우면서, 데이터를 단순히 소비하는 것이 아니라 관계와 참조 구조로 이해하게 되었다.

마침 Supabase를 알게 되었고, 같은 서비스를 다른 개발 환경에서 다시 구현해보고 싶다는 생각이 들었다.

버전2는 단순한 리팩토링이 아니라, 설계 관점을 바꿔보는 실험이었다.

> 가장 어려웠던 점, 상태 관리와 타입 설계

퍼블리셔 경험은 있었지만, 실제 서비스 관점에서 에러를 설계해본 적은 없었다.

에러가 발생할 수 있는 상황은 예측할 수 있었지만,

- 사용자에게 어떤 피드백을 보여줄지

- 재요청은 어떻게 처리할지

- 로딩과 에러 상태를 어디까지 분리할지

이런 부분은 머릿속 시뮬레이션으로만 설계해야 했다.

또한 TypeScript를 처음 도입하면서 초기 타입 설계를 잘못해

전반적인 타입 구조를 다시 수정하는 경험을 했다.

이 과정에서 깨달은 점은 분명했다.

타입은 단순한 오류 방지 도구가 아니라,

데이터 구조에 대한 ‘약속’이자 설계의 일부라는 것.

이 경험 이후, 기능을 만들기 전에 데이터 구조와 타입을 먼저 고민하게 되었다.

> 설계의 한계를 마주하다

Next.js를 사용했지만 SEO의 장점을 충분히 활용하지 못했다.

CSR 중심으로 구현하면서 서버 렌더링을 전략적으로 활용하지 못한 점은 아쉬움으로 남는다.

또한 컴포넌트를 “하나의 책임만 갖도록” 분리하는 것이 생각보다 훨씬 어렵다는 것을 체감했다.

처음에는 완벽하게 분리했다고 생각했지만, 기능이 추가되면서 예상치 못한 결합도가 드러났고 구조를 다시 고민해야 했다.

그 경험을 통해 설계는 설계는 처음부터 완벽한 것이 아니라 수정되며 다듬어지는 과정이라는 것을 깨달았다.

> 이 프로젝트 이후 달라진 점

이 프로젝트를 통해 실력이 급격히 향상되었다기보다 설계를 바라보는 시각이 달라졌다.

- 이 구조는 확장에 안전한가?
- 상태의 경계는 명확한가?
- 만약 팀 프로젝트였다면 유지보수하기 쉬운가?

특히 “만약 팀프로젝트였다면?”이라는 질문을 스스로 던지게 된 점이 가장 큰 변화였다.

이 질문이 컴포넌트 책임, 타입 설계, 상태 관리 구조를 더 깊이 고민하게 만들었다.
